
nginx:
======
$ docker logs cyber-dojo-nginx
2016/10/31 21:49:03 [emerg] 1#1: mkdir() "/var/cache/nginx/client_temp" failed (13: Permission denied)
nginx: [emerg] mkdir() "/var/cache/nginx/client_temp" failed (13: Permission denied)
2016/10/31 21:49:54 [warn] 1#1: the "user" directive makes sense only if the master process runs with super-user privileges, ignored in /etc/nginx/nginx.conf:2
Changed to user root in docker-compose.yml
No longer get this diagnostic but still not getting images from nginx.

runner_server:
==============
o) will [cyber-dojo start-point pull NAME] need runner.pull(image_name)

o) add cpu/memory/swap limits
   See comments at https://github.com/cyber-dojo/commander/blob/master/docker-compose.yml
   See https://github.com/docker/docker/pull/9437
   for suggestion that limits might be uid/gid based.
   Should I use cyber-dojo user and not nobody:nogroup ?
   What if the image does not have cyber-dojo user?
   I guess I can just use its integer id, 19661

   From [docker run --help]

   --blkio-weight value          Block IO (relative weight), between 10 and 1000
   --blkio-weight-device value   Block IO weight (relative device weight) (default []
   --cpu-period int              Limit CPU CFS (Completely Fair Scheduler) period
   --cpu-quota int               Limit CPU CFS (Completely Fair Scheduler) quota
   -c, --cpu-shares int          CPU shares (relative weight)
   --device-read-bps value       Limit read rate (bytes per second) from a device (default [])
   --device-read-iops value      Limit read rate (IO per second) from a device (default [])
   --device-write-bps value      Limit write rate (bytes per second) to a device (default [])
   --device-write-iops value     Limit write rate (IO per second) to a device (default [])
   --isolation string            Container isolation technology
   --kernel-memory string        Kernel memory limit
   -m, --memory string           Memory limit
   --memory-reservation string   Memory soft limit
   --memory-swap string          Swap limit equal to memory plus swap: '-1' to enable unlimited swap
   --memory-swappiness int       Tune container memory swappiness (0 to 100) (default -1)
   --pids-limit int              Tune container pids limit (set -1 for unlimited)
   --ulimit value                Ulimit options (default [])


o) what if filename has a quote in it?

o) log assert_exec() fail in docker_runner.rb

o) can you copying a changed file into the container via a named-pipe?
   - https://en.wikipedia.org/wiki/Named_pipe
   - https://github.com/shurizzle/ruby-mkfifo

   File.mkfifo('/tmp/file')
   tar -zcf /tmp/file | docker exec ... sh -c 'tar -zxf - -C /sandbox'
   IO.write('/tmp/file', content)
   `rm /tmp/file`

o) validate microservice parameters?
   - kata_id = 10 hex chars
   - avatar_name = one of the known 64 animals
   - max_seconds = integer (with max of 15 seconds?)
   - deleted_filenames (what chars are illegal in linux filename?)
   - changed_files

o) Should there be a volume per kata rather than per animal?
   This feels right. Fits with the value-system of cyber-dojo.
   Keeps the number of volumes down too.
   Means hello()/goodbye() will only need kata_id.
   And could be renamed... new_kata(id), old_kata(id)
   Resuming an avatar will need to redo the new_kata(id)

o) Should I use a different uid for the run of each avatar
   and for the rights of their files?

==============================================================================

Suppose there was a container per kata, which started when the kata was
created. When you hit test your code was run in that container. Viz
the server would not need to start a new container for each test submission.
Can you still have a volume per avatar? No. The volume needs to be mounted
when the container is created. So there would need to be a volume per kata.
Means I would need two new event-methods, new_kata, old_kata.
Implications of this...
o) /sandbox is no longer going to work. Would need something like
   /sandboxes/lion
   /sandboxes/salmon
o) new_kata() would create the new volume and the new container
o) old_kata() would remove the volume and the container and would become important.
o) suggests kata creation should be time-limited at creation so the old_kata()
   calls can happen at a known time.
o) forking from an old traffic-light would create a new kata with a new container.
   its database (eg) would be empty again.
o) new_avatar(lion) would create /sandboxes/lion and give it appropriate rights/ownership.
   There need not be a lion username, but each avatar would have to be associated
   with a unique uid and that uid would own the /sandboxes/lion
o) there could be users with the avatar's name. Perhaps new language images should be
   created from a new user-base image that has 64 users in it ready.
o) old_avatar(lion) would remove /sandboxes/lion
o) There is one red_amber_green lambda that uses /sandbox in its regex.
   It's Go-testing. Could change that now.
   At least do Go-testing withs
o) pull_image?() and pull_image() would drop away!
   Instead new_kata(image_name, kata_id) would be called when new kata is created
   and it would do the docker-pull it it needed to.
o) I will need to use the kata-id as a key to retrieve the cid value.
   Could use a /sandboxes/manifest.json that stores the cid.
   Or name the container.
   https://docs.docker.com/engine/reference/commandline/ps/#filtering
   docker run --detach ... --name cyber_dojo_#{kata_id} ...
   49f94802344e......
   That's the name of the container. Not its cid.
   But you can still use it to find the container... Yes
   docker ps --quiet --filter "name=cyber_dojo_#{kata_id}"
   49f94802344e

o) DO I NEED A VOLUME? Why not just use the state inside the container?

o) Can you limit the disk-allocation inside a container? Depends on the driver.
   https://github.com/docker/docker/issues/3804
     docker run ... --storage-opt size=120G ...

o) Note that I am already limiting the duration of a [docker exec]

o) Another effect of this would be that I would not need to pass
   image_name to run()
   This means all the information needed to do a run would come directly
   from the browser. No need to go to storer at all.

o) Could the new_kata() container creation be done with a command that
   includes the duration of the kata. So the container automatically
   expires at its deadline. sleep!
   This would indeed prevent subsequent [docker exec]'s
   But the container would still exist in an exited state.
   I can solve that by doing a [cyber-dojo clean] before!
   This creates a very small delay but not on [test] (on kata creation)
   This means the duration of a kata will need to be part of the process
   of creating a kata. Should I offer a choice or just have one (eg 1 day)

o) A duration ties in strongly with James' idea of a readonly kata.
   A simple button to "finish"/"publish" a kata is needed.
   Note that the duration choice might have to be re-offered (if there
   is a choice) when you fork.

o) new_kata() creates the container and the base /sandboxes dir.
o) new_avatar(lion) creates a new user called lion in the container.
   it creates /sandboxes/lion and gives lion ownership of it.
   it makes /sandboxes/lion the HOME for lion.

o) A big implication of having a container per kata is that containers
   are now long-lived. This means Alpine images need to have tini.
   This needs to be tested for. Would be handy to have a list of which
   images are Ubuntu based and which are Alpine based...
   Everything is Ubuntu except these 6 which are Alpine...
   Alpine C,gcc,assert   from language_base?
   Alpine C#,Moq
   Alpine Ruby,Cucumber
   Alpine Ruby,MiniTest
   Alpine Ruby,Rspec
   Alpine Ruby,TestUnit




