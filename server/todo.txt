
-------------------------------------------------
runner_server:
-------------------------------------------------

o) Should there be a volume per kata rather than per animal?
   This feels right. Fits with the value-system of cyber-dojo.
   Keeps the number of volumes down too.
   Means hello()/goodbye() will only need kata_id.
   And could be renamed... new_kata(id), old_kata(id)
   Resuming an avatar will need to redo the new_kata(id)

o) client runner_test.rb E6F reveals a problem on the runner_server
   Here's the log (after the test has finished)

   runner_server | 12:59:13 web.1 | "COMMAND:docker volume rm cyber_dojo_201BCE6F_salmon"
   runner_server | 12:59:13 web.1 | Error response from daemon: Unable to remove volume,
      volume still in use: remove cyber_dojo_201BCE6F_salmon: volume is in use -
      [b66474ead6b0720c71a120cde915b20d88c9560a158e4b4f8302fd0d9baf382b]

   doing [docker ps -a] shows that b6647... is *not* there
   but of course at the time it was.
   doing [docker volume ls] shows [local cyber_dojo_201BCE6F_salmon] is there.
   This relates to the child-process [docker rm]...
   Note runner_server's microservice's goodbye() does *not* have the
   synchronization that docker_helpers_test.rb has. It should have!
   goodbye() on the runner-server should be self-contained.
   Remember the volume is not where the traffic-lights are stored
   it is where the run() takes place. Nevertheless the potential
   exists for one avatar to overwrite another avatars files.
   Should I use a different uid for the run of each avatar
   and for the rights of their files?

   Do the 10 second timeout in Ruby.
   This removes the need for docker_runner.sh

      require timeout
      # note: use --workdir in create_container to avoid needing to do cd?

      def run(cid, max_seconds)
        # http://stackoverflow.com/questions/8292031/ruby-timeouts-and-system-commands
        cmd = "docker exec --user=nobody --interactive #{cid} sh -c './cyber-dojo.sh'"
        rout, wout = IO.pipe
        rerr, werr = IO.pipe
        pid = Process.spawn(cmd, pgroup:true, out:wout, err:werr)
        begin
          Timeout::timeout(max_seconds) do
            Process.waitpid(pid)
            wout.close
            werr.close
            stdout = rout.readlines.join
            stderr = rerr.readlines.join
            return [true, stdout, stderr]
          end
        rescue Timeout::Error
          Process.kill(-9, pid)
          Process.detach(pid)
          return [false, '', '']
        ensure
          wout.close unless wout.closed?
          werr.close unless werr.closed?
          rout.close
          rerr.close
        end
      end

      def remove_container(cid)
        # ask the docker daemon to remove the container
        shell.exec("docker rm -f #{cid}")
        # wait max 2 secs till it's gone
        200.times do
          # do the sleep first to keep test coverage at 100%
          sleep(1.0 / 100.0)
          break if container_dead?(cid)
        end
      end

      def container_dead?(cid)
        # See https://gist.github.com/ekristen/11254304
        cmd = "docker inspect --format='{{ .State.Running }}' #{cid} 2> /dev/null"
        _, status = shell.exec(cmd)
        dead = status == 1
      end

      # in micro_service.rb
      post '/run' do
        status, output = runner.create_container(image_name, kata_id, avatar_name)
        # return jasoned(logged(output, 'error')) if status == 'error'

        cid = output.strip

        status, output = runner.delete_files(cid, deleted_filenames)
        # return jasoned(logged(output, 'error')) if status == 'error'

        status, output = runner.change_files(cid, changed_files)
        # return jasoned(logged(output, 'error')) if status == 'error'

        status output = runner.setup_home(cid)
        # return jasoned(logged(output, 'error')) if status == 'error'

        status, stdout, _stderr = runner.run(cid, max_seconds)
        # return jasoned(logged(output, 'error')) if status == 'error'

        runner.remove_container(cid) # ensure

        jasoned truncated(cleaned(stdout)), status
      end


o) write the hello()-datetime to a known file inside the volume.
   write the run()-datetime to a known file inside the volume.
   Separate reaper/pruner service can delete old volumes.

o) massage micro_service returned strings.
   - clean them
   - truncate them

o) client tests: would be nice to set runner_server's Logger
    to NullLogger, or to quieter logger, eg one that does not log success
    Getting lots of stdout loggin from the runner-server when the
    runner-client calls into it.

o) runner_server micro-service needs to check each shell call and return
   { status:error, output:msg }
   if somthing goes wrong.

o) add cpu/memory/swap limits
   See comments at https://github.com/cyber-dojo/commander/blob/master/docker-compose.yml
   See https://github.com/docker/docker/pull/9437
   for suggestion that limits might be uid/gid based.
   Should I use cyber-dojo user and not nobody:nogroup ?
   What if the image does not have cyber-dojo user?
   I guess I can just use its integer id, 19661

   From [docker run --help]
   --blkio-weight value          Block IO (relative weight), between 10 and 1000
   --blkio-weight-device value   Block IO weight (relative device weight) (default []
   --cpu-period int              Limit CPU CFS (Completely Fair Scheduler) period
   --cpu-quota int               Limit CPU CFS (Completely Fair Scheduler) quota
   -c, --cpu-shares int
   --device-read-bps value       Limit read rate (bytes per second) from a device (default [])
   --device-read-iops value      Limit read rate (IO per second) from a device (default [])
   --device-write-bps value      Limit write rate (bytes per second) to a device (default [])
   --device-write-iops value     Limit write rate (IO per second) to a device (default [])
   --isolation string            Container isolation technology
   --kernel-memory string        Kernel memory limit
   -m, --memory string               Memory limit
   --memory-reservation string   Memory soft limit
   --memory-swap string          Swap limit equal to memory plus swap: '-1' to enable unlimited swap
   --memory-swappiness int       Tune container memory swappiness (0 to 100) (default -1)
   --pids-limit int              Tune container pids limit (set -1 for unlimited)
   --ulimit value                Ulimit options (default [])

o) what if filename has a quote in it?

o) log assert_exec() fail in docker_runner.rb

-------------------------------------------------

o) [./cyber-dojo update]
   does not update the language images. Should it?